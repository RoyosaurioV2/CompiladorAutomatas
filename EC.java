/* Generated By:JavaCC: Do not edit this line. EC.java */
import java.util.ArrayList;
import java.io.*;
import java.util.*;
import java.util.function.*;
import java.util.stream.Collectors;
import java.util.stream.*;
import java.lang.reflect.*;
//import ManejoErrores;

public class EC implements ECConstants {

    final ExpresionVariable ERROR = new ExpresionVariable("", TipoDato.INDEFINIDO).conError(true);

    int tempCount = 1;
    int siCount = 1;
    int conCount = 1;
    int cicCount = 1;

    Expresion hacerBinaria(Token operador, List<Expresion> expresiones) {

        Expresion izq;
        Expresion der;

        switch(expresiones.size()) {
            case 1:
                return expresiones.removeFirst();
            case 2:
                izq = expresiones.removeFirst();
                der = expresiones.removeFirst();
                return new ExpresionBinaria(operador, izq, der);
            default:
                izq = expresiones.removeFirst();
                der = hacerBinaria(operador, expresiones);
                return new ExpresionBinaria(operador, izq, der);
        }

    }

    Expresion hacerBinaria(List<Token> ops, List<Expresion> expresiones) {

        Expresion izq;
        Expresion der;

        switch(expresiones.size()) {
            case 1:
                return expresiones.removeFirst();
            case 2:
                izq = expresiones.removeFirst();
                der = expresiones.removeFirst();
                return new ExpresionBinaria(ops.removeFirst(), izq, der);
            default:
                Token operador = ops.removeFirst();
                izq = expresiones.removeFirst();
                der = hacerBinaria(ops, expresiones);
                return new ExpresionBinaria(operador, izq, der);

        }

    }

    final Integer[] SENTENCES_BEGIN = new Integer[]
            {VARIABLE, ESTABLECER, INTERPRETAR, ESCRIBIR, INICIO_CONDICIONAL_SI, INICIO_CONDICIONAL_CONFORME,
            INICIO_CICLO_PARA, INICIO_CICLO_REPETIR, INICIO_CICLO_MIENTRAS};

    final ArrayList<String> tablaErrores = new ArrayList<String>();

    final ArrayList<Quadruple> quadruples = new ArrayList<Quadruple>();

    public class Ambito {

        public final HashMap<String, Expresion> tablaSimbolos;

        public Ambito(){
            tablaSimbolos = new HashMap<String, Expresion>();
        }

        public Ambito(Ambito from){
            this();

            tablaSimbolos.putAll(from.tablaSimbolos);
        }
    }

    public class Quadruple {

        public String op;
        public String arg1;
        public String arg2;
        public String result;
        public int nivel;

        public Quadruple(String op, String arg1, String arg2, int nivel) {
            this.op = op;
            this.arg1 = arg1;
            this.arg2 = arg2;
            this.nivel = nivel;
            this.result = nivel == 0 ? "" : "t" + tempCount++;
            quadruples.add(this);
        }

        public Quadruple(String op, String arg1, String arg2) {
            this(op, arg1, arg2, 1);
        }

        public Quadruple(String op, String arg1, String arg2, String result, int nivel) {
            this.op = op;
            this.arg1 = arg1 == null ? "" : arg1;
            this.arg2 = arg2 == null ? "" : arg2;
            this.result = result;
            this.nivel = nivel;
            quadruples.add(this);
        }

        public Quadruple(String op, String arg1, String arg2, String result) {
            this(op, arg1, arg2, result, 1);
        }

        public String toString() {

            ArrayList<String> elem = new ArrayList<String>(4);
            elem.add(op);
            if(!arg1.isBlank()) elem.add(arg1);
            if(!arg2.isBlank()) elem.add(arg2);
            if(!result.isBlank()) elem.add(result);

            return "\t".repeat(nivel) + String.join(" ", elem);
        }

    }

    public static class TipoDato {

        public final static TipoDato INDEFINIDO = new TipoDato(-2, "Indefinido");
        public final static TipoDato VACIO = new TipoDato(-1, "Vac\u00edo");
        public final static TipoDato ENTERO = new TipoDato(ECConstants.ENTERO << 1, "Entero");
        public final static TipoDato FLOTANTE = new TipoDato(ECConstants.FLOTANTE << 1, "Flotante");
        public final static TipoDato CADENA = new TipoDato(ECConstants.CADENA << 1, "Cadena");
        public final static TipoDato CARACTER = new TipoDato(ECConstants.CARACTER << 1, "Caracter");
        public final static TipoDato BOOLEANO = new TipoDato(ECConstants.BOOLEANO << 1, "Booleano");

        public static TipoDato desdeTipo(int tipoDato) {

            switch (tipoDato) {
                case -1:
                    return VACIO;
                case ECConstants.ENTERO << 1:
                    return ENTERO;
                case ECConstants.FLOTANTE << 1:
                    return FLOTANTE;
                case ECConstants.CADENA << 1:
                    return CADENA;
                case ECConstants.CARACTER << 1:
                    return CARACTER;
                case ECConstants.BOOLEANO << 1:
                    return BOOLEANO;
                default:
                    return INDEFINIDO;
            }
        }

        private int _hash;
        private String _nombre;
        private int _dimension;
        private TipoDato _interno;

        private TipoDato(int hash, String nombre, TipoDato interno, int dimension) {
            _hash = hash;
            _nombre = nombre;
            _dimension = dimension;
            _interno = interno;
        }

        private TipoDato(int hash, String nombre) {

            _hash = hash;
            _nombre = nombre;
            _dimension = 0;
            _interno = this;
        }

        public String getNombre() {
            return _nombre + "[]".repeat(_dimension);
        }

        public int getDimension() {
            return _dimension;
        }

        public boolean esArreglo(){
            return (_hash & 1) != 0;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            TipoDato tipoDato = (TipoDato) o;
            return _hash == tipoDato._hash && _dimension == tipoDato._dimension;
        }
        @Override
        public int hashCode() {
            return Objects.hash(_hash, _dimension);
        }

        public TipoDato getTipoInterno(){
            return _interno;
        }

        public TipoDato getTipoInterno(int dimension){

            TipoDato interno = this;

            for (int i = 0; i < dimension; ++i) {
                interno = interno._interno;
            }

            return interno;
        }

        public TipoDato getTipoArreglo(int dimension){

            if (this.equals(INDEFINIDO) || this.equals(VACIO)) return this;

            return new TipoDato(_hash | 1, _nombre, this, dimension);
        }

        public TipoDato getTipoArreglo() {
            return getTipoArreglo(_dimension + 1);
        }

        public boolean puedeUtilizar(int operador) {

            if(esArreglo()) return false;

            boolean eq = false;
            int tipoDato = _hash;

            switch(operador){
                case ECConstants.SUMA:
                    return tipoDato == ENTERO._hash || tipoDato == FLOTANTE._hash
                    || tipoDato == CADENA._hash || tipoDato == CARACTER._hash;

                case ECConstants.RESTA:
                case ECConstants.MULTIPLICACION:
                case ECConstants.DIVISION:
                case ECConstants.MODULO:
                    return tipoDato == ENTERO._hash || tipoDato == FLOTANTE._hash;

                case ECConstants.LOGICO_NOT:
                case ECConstants.LOGICO_OR:
                case ECConstants.LOGICO_AND:
                    return tipoDato == BOOLEANO._hash;

                case ECConstants.OPERADOR_IGUAL:
                case ECConstants.OPERADOR_DIFERENTE:
                    eq = tipoDato == CADENA._hash || tipoDato == BOOLEANO._hash;

                case ECConstants.OPERADOR_MAYOR:
                case ECConstants.OPERADOR_MAYOR_IGUAL:
                case ECConstants.OPERADOR_MENOR:
                case ECConstants.OPERADOR_MENOR_IGUAL:
                    return eq || tipoDato == ENTERO._hash || tipoDato == FLOTANTE._hash
                        || tipoDato == CARACTER._hash;
            }

            return false;
        }

    }

    public abstract class Expresion implements Cloneable {

        protected boolean _error;
        protected Quadruple _quadruple;

        public abstract int getTipoExpresion();
        public abstract TipoDato getTipo();
        public abstract String toString();
        public abstract Quadruple toQuadrupleImp();

        public final static int EXP_CONSANTE = 1;
        public final static int EXP_VARIABLE = 2;
        public final static int EXP_FUNCION = 3;
        public final static int EXP_INDICE = 4;

        public final static int EXP_SUMA = ECConstants.SUMA;                        // a + b, +a
        public final static int EXP_RESTA = ECConstants.RESTA;                      // a - b, -a
        public final static int EXP_DIVISION = ECConstants.DIVISION;                // a / b
        public final static int EXP_MULTIPLICACION = ECConstants.MULTIPLICACION;    // a * b
        public final static int EXP_MODULO = ECConstants.DIVISION;                  // a % b
        public final static int EXP_MENOR = ECConstants.OPERADOR_MENOR;             // a < b
        public final static int EXP_MENOR_IGUAL = ECConstants.OPERADOR_MENOR_IGUAL; // a <= b
        public final static int EXP_MAYOR = ECConstants.OPERADOR_MAYOR;             // a > b
        public final static int EXP_MAYOR_IGUAL = ECConstants.OPERADOR_MAYOR_IGUAL; // a >= b
        public final static int EXP_IGUAL = ECConstants.OPERADOR_IGUAL;             // a == b
        public final static int EXP_DIFERENTE = ECConstants.OPERADOR_DIFERENTE;     // a != b
        public final static int EXP_ASIGNACION = ECConstants.ASIGNACION;            // a = b
        public final static int EXP_AND = ECConstants.LOGICO_AND;                   // a && b
        public final static int EXP_OR = ECConstants.LOGICO_OR;                     // a || b

        public final static int EXP_NO = ECConstants.LOGICO_NOT;                    // !a

        public Quadruple toQuadruple() {

            if (_quadruple == null) {

                _quadruple = toQuadrupleImp();

            }

            return _quadruple;
        }

        public boolean esError() {
            return _error;
        }

        public <TExpresion extends Expresion> TExpresion conError(boolean error) {

            if(_error == error) return (TExpresion)this;

            try{
                Expresion copy = (Expresion)clone();
                copy.setError(error);
                return (TExpresion)copy;
            } catch (CloneNotSupportedException ex) {
                this._error = error;
                return (TExpresion)this;
            }

        }

        private void setError(boolean error) {
            _error = error;
        }

    }

    public class ExpresionVariable extends Expresion {

        private String _nombre;
        private TipoDato _tipo;

        public ExpresionVariable(String nombre, TipoDato tipo) {
            _nombre = nombre;
            _tipo = tipo;
        }

        public String getNombre() {
            return _nombre;
        }

        public int getTipoExpresion() {
            return Expresion.EXP_VARIABLE;
        }

        public TipoDato getTipo() {
            return _tipo;
        }

        public String toString() {
            return _nombre;
        }

        public Quadruple toQuadrupleImp() {
            return new Quadruple("Est", "", "", "@" + _nombre);
        }

    }

    public class ExpresionConstante extends Expresion {

        private String _valor;
        private TipoDato _tipo;

        public ExpresionConstante(String valor, TipoDato tipo) {
            _valor = valor;
            _tipo = tipo;
        }

        public int getTipoExpresion() {
            return Expresion.EXP_CONSANTE;
        }

        public TipoDato getTipo() {
            return _tipo;
        }

        public String getValor() {
            return _valor;
        }

        public String toString() {
            return _valor.toString();
        }

        public Quadruple toQuadrupleImp() {
            return new Quadruple("=", _valor, "");
        }

    }

    public class ExpresionIndice extends Expresion {

        private ExpresionVariable _arreglo;
        private List<Expresion> _indices;

        public ExpresionIndice(List<Expresion> indices){
            _indices = Collections.unmodifiableList(indices);
        }

        public ExpresionVariable getArreglo() {
            return _arreglo;
        }

        public void setArreglo(Expresion arreglo) {

            if (arreglo instanceof ExpresionVariable)
                _arreglo = (ExpresionVariable)arreglo;
            else
                _arreglo = ERROR;

        }

        public int getTipoExpresion() {
            return Expresion.EXP_INDICE;
        }

        public TipoDato getTipo() {
            return _arreglo.getTipo().getTipoInterno(_indices.size());
        }

        public List<Expresion> getIndices() {
            return _indices;
        }

        public int getDimension() {
            return _indices.size();
        }

        public Quadruple toQuadrupleImp() {

            StringBuilder sb = new StringBuilder();

            Quadruple arreglo = _arreglo.toQuadruple();

            sb.append(arreglo.result);
            // quadruples.add(arreglo);

            for (Expresion indice : _indices) {

                Quadruple q = indice.toQuadruple();
                // quadruples.add(q);

                sb.append('[')
                  .append(q.result)
                  .append(']');

            }

            return new Quadruple("=", sb.toString(), "");
        }

        public String toString() {

            StringBuilder sb = new StringBuilder();

            sb.append(_arreglo.getNombre());

            for (Expresion _indice : _indices) {
                sb.append('[')
                  .append(_indices)
                  .append(']');
            }

            return sb.toString();
        }

    }

    public class ExpresionFuncion extends Expresion {

        private String _nombre;
        private TipoDato _tipo;
        private List<Expresion> _argumentos;

        public ExpresionFuncion(String nombre, TipoDato tipo, List<Expresion> argumentos) {
            _nombre = nombre;
            _tipo = tipo;
            _argumentos = Collections.unmodifiableList(argumentos);
        }

        public boolean argumentosCompatibles(List<Expresion> argumentos) {

            List<TipoDato> _tiposDato = _argumentos
                                        .stream()
                                        .map(mapper)
                                        .toList();

            List<TipoDato> tiposDato = argumentos
                                        .stream()
                                        .map(mapper)
                                        .toList();

            return _tiposDato.equals(tiposDato);
        }

        public int getTipoExpresion() {
            return Expresion.EXP_FUNCION;
        }

        public TipoDato getTipo() {
            return _tipo;
        }

        public List<Expresion> getArgumetos() {
            return _argumentos;
        }

        public String getNombre() {
            return _nombre;
        }

        public String toString() {
            return _nombre;
        }

        public Quadruple toQuadrupleImp() {
            return new Quadruple("Ir", _nombre, "");
        }

        private final Function<Expresion, TipoDato> mapper = new Function<Expresion, TipoDato>() {
            @Override
            public TipoDato apply(Expresion e){
                return e.getTipo();
            }
        };

    }

    public class ExpresionBinaria extends Expresion {

        private Token _operador;
        private Expresion _izq;
        private Expresion _der;
        private TipoDato _tipo;

        public ExpresionBinaria(Token operador, Expresion izq, Expresion der, TipoDato tipo) {
            _operador = operador;
            _izq = izq;
            _der = der;
            _tipo = tipo;
        }

        public ExpresionBinaria(Token operador, Expresion izq, Expresion der){
            this(operador, izq, der, izq.getTipo());
        }

        public Expresion getIzquierdo(){
            return _izq;
        }

        public Expresion getDerecho(){
            return _der;
        }

        public int getTipoExpresion() {
            return _operador.kind;
        }

        public TipoDato getTipo() {
            return _tipo;
        }

        public String toString() {

            return _operador + " " + _izq + " " + _der;
        }

        public Quadruple toQuadrupleImp() {

            Quadruple izq = _izq.toQuadruple();
            Quadruple der = _der.toQuadruple();

            // quadruples.add(izq);
            // quadruples.add(der);

            return new Quadruple(_operador.image, izq.result, der.result);
        }

    }

    public class ExpresionUnaria extends Expresion {

        private Token _operador;
        private Expresion _operando;
        private TipoDato _tipo;

        public ExpresionUnaria(Token operador, Expresion operando, TipoDato tipo){
            _operador = operador;
            _operando = operando;
            _tipo = tipo;
        }

        public ExpresionUnaria(Token operador, Expresion operando){
            this(operador, operando, operando.getTipo());
        }

        public Expresion getOperando(){
            return _operando;
        }

        public int getTipoExpresion() {
            return _operador.kind;
        }

        public TipoDato getTipo() {
            return _tipo;
        }

        public String toString() {

            return _operador + " " + _operando;
        }

        public Quadruple toQuadrupleImp() {

            Quadruple operando = _operando.toQuadruple();
            // quadruples.add(operando);

            return new Quadruple(_operador.image, operando.result, "");
        }

    }
/*
    public class Expresion {

        public String nombre;

        public int tipoDato;

        public int tipoExpresion = EXP_VARIABLE;

        public Token token;

        public ArrayList<Expresion> expresiones = new ArrayList<Expresion>();

        public boolean isError = false;

        public static final Function<Expresion, Integer> mapper = new Function<Expresion, Integer>() {
            @Override
            public Integer apply(Expresion e){
                return e.tipoDato;
            }
        };

        public static final Predicate<Expresion> errorP = new Predicate<Expresion>() {
             @Override
             public boolean test(Expresion e) {
                 return e.isError;
             }
         };

        public boolean tieneErrores() {

            if (isError) return true;

            return expresiones.stream().anyMatch(Expresion.errorP);
        }

        public static String getTipoDatoNombre(int tipoDato){

            switch (tipoDato){

                case TIPO_VACIO:
                    return "Vacio";
                case TIPO_ENTERO:
                    return "Entero";
                case TIPO_FLOTANTE:
                    return "Flotante";
                case TIPO_CADENA:
                    return "Cadena";
                case TIPO_CARACTER:
                    return "Caracter";
                case TIPO_BOOLEANO:
                    return "Booleano";

                case TIPO_ENTERO | 1:
                    return "Entero[]";
                case TIPO_FLOTANTE | 1:
                    return "Flotante[]";
                case TIPO_CADENA | 1:
                    return "Cadena[]";
                case TIPO_CARACTER | 1:
                    return "Caracter[]";
                case TIPO_BOOLEANO | 1:
                    return "Booleano[]";

            }

            return "Indefinido";
        }

        public static boolean isArreglo(int tipoDato) {
            return (tipoDato & 1) != 0;
        }

        public static boolean puedeOperar(int tipoDato, int operador){

            boolean eq = false;

            switch(operador){
                case ECConstants.SUMA:
                    return tipoDato == TIPO_ENTERO || tipoDato == TIPO_FLOTANTE
                    || tipoDato == TIPO_CADENA || tipoDato == TIPO_CARACTER;
                case ECConstants.RESTA:
                case ECConstants.MULTIPLICACION:
                case ECConstants.DIVISION:
                case ECConstants.MODULO:
                    return tipoDato == TIPO_ENTERO || tipoDato == TIPO_FLOTANTE;

                case ECConstants.LOGICO_NOT:
                case ECConstants.LOGICO_OR:
                case ECConstants.LOGICO_AND:
                    return tipoDato == TIPO_BOOLEANO;

                case ECConstants.OPERADOR_IGUAL:
                case ECConstants.OPERADOR_DIFERENTE:
                    eq = tipoDato == TIPO_CADENA || tipoDato == TIPO_BOOLEANO;
                case ECConstants.OPERADOR_MAYOR:
                case ECConstants.OPERADOR_MAYOR_IGUAL:
                case ECConstants.OPERADOR_MENOR:
                case ECConstants.OPERADOR_MENOR_IGUAL:
                    return eq || tipoDato == TIPO_ENTERO || tipoDato == TIPO_FLOTANTE
                        || tipoDato == TIPO_CARACTER;
            }

            return false;

        }
    }
*/
    public static class Reporte {

        public boolean isError = false;

        public List<String> lineas = new ArrayList<String>();

        public ArrayList<Quadruple> codigoIntermedio = new ArrayList<Quadruple>();

    }

    private static final Function<String, String> formaLista = new Function<String, String>() {
        @Override
        public String apply(String s){
            return "- " + s;
        }
    };

    private static final Function<String, String> tabMapper = new Function<String, String>() {
        @Override
        public String apply(String s){
            return s.replace("\t", "    ");
        }
    };

    private static final Function<String, Stream<String>> flatMapper = new Function<String, Stream<String>>() {
        @Override
        public Stream<String> apply(String s){
            return Stream.of(s.split("\n"));
        }
    };

    private static final ToIntFunction<String> intMapper = new ToIntFunction<String>() {
        @Override
        public int applyAsInt(String s){
            return s.length();
        }
    };

    private static final Predicate<Field> fieldFilter = new Predicate<Field>() {
        @Override
        public boolean test(Field f){
            return f.getType() == int.class;
        }
    };

    private static final BinaryOperator<String> fieldMarge = new BinaryOperator<String>() {
        @Override
        public String apply(String x, String y){
            return x;
        }
    };

    private static final Function<Field, Integer> keyMapper = new Function<Field, Integer>() {
        @Override
        public Integer apply(Field f) {
            try{
                return f.getInt(null);
            } catch (IllegalAccessException ex) {
                return 0;
            }

        }
    };

    private static final Function<Field, String> valueMapper = new Function<Field, String>() {
        @Override
        public String apply(Field f){
            return f.getName();
        }
    };

    private static final Map<Integer, String> tiposTokens
    = Arrays.stream(ECConstants.class.getDeclaredFields())
                                  .filter(fieldFilter)
                                  .collect(Collectors.toMap(keyMapper, valueMapper, fieldMarge));

    public static Reporte lexica(String archivo) {
        Reporte reporte = new Reporte();

        if (archivo.isBlank()) {
            reporte.lineas.add("ERROR: Debe de ingresar el archivo del c\u00f3digo fuente.");
            reporte.isError = true;
            return reporte;
        }

        try {

            FileReader sourceFileReader = new FileReader(archivo);

            EC ec = new EC(sourceFileReader);

            reporte.lineas.add("Fase l\u00e9xica: Tipo -> Valor.");

            for(Token token = ec.getNextToken(); token.kind != ECConstants.EOF; token = ec.getNextToken()) {

                String tipo = tiposTokens.get(token.kind);
                reporte.lineas.add(String.format("\t<%s> -> %s", tipo, token.image));

            }

            var errores = ec.tablaErrores;

            if (!errores.isEmpty()){

                reporte.isError = true;
                reporte.lineas.clear();
                String str1 = "encontraron";
                String str2 = "errores";
                int cErrores = errores.size();

                if (cErrores == 1) {
                    str1 = "encontr\u00f3";
                    str2 = "error";
                }

                reporte.lineas.add(String.format("Se %s %d %s durante la prueba l\u00e9xica:", str1, cErrores, str2));
                reporte.lineas.add(" ");

                var errors = errores.stream()
                                  .map(formaLista)
                                  .flatMap(flatMapper)
                                  .map(tabMapper)
                                  .toList();

                reporte.lineas.addAll(errors);

            }else{
                reporte.lineas.add("Se pas\u00f3 la prueba l\u00e9xica con \u00e9xito.");
                reporte.lineas.add("No se encontraron errores.");
            }

            return reporte;

        } catch (FileNotFoundException ex) {
            reporte.lineas.add("ERROR: No se encontr\u00f3 el archivo.");
            reporte.isError = true;
        }

        return reporte;
    }

    public static Reporte semantica(String archivo) {

        Reporte reporte = new Reporte();

        if (archivo.isBlank()) {
            reporte.lineas.add("ERROR: Debe de ingresar el archivo del c\u00f3digo fuente.");
            reporte.isError = true;
            return reporte;
        }

        try {

            FileReader sourceFileReader = new FileReader(archivo);

            EC ec = new EC(sourceFileReader);

            ec.programa();

            var errores = ec.tablaErrores;

            reporte.codigoIntermedio = ec.quadruples;

            reporte.lineas.add("Se pas\u00f3 la prueba sem\u00e1ntica con \u00e9xito.");
            reporte.lineas.add("No se encontraron errores.");

            if (!errores.isEmpty()){

                reporte.isError = true;
                reporte.lineas.clear();
                String str1 = "encontraron";
                String str2 = "errores";
                int cErrores = errores.size();

                if (cErrores == 1) {
                    str1 = "encontr\u00f3";
                    str2 = "error";
                }

                reporte.lineas.add(String.format("Se %s %d %s durante la prueba sem\u00e1ntica:", str1, cErrores, str2));
                reporte.lineas.add(" ");

                var errors = errores.stream()
                                  .map(formaLista)
                                  .flatMap(flatMapper)
                                  .toList();

                reporte.lineas.addAll(errors);
            }

            return reporte;

        } catch (FileNotFoundException ex) {
            reporte.lineas.add("ERROR: No se encontr\u00f3 el archivo.");
            reporte.isError = true;
        } catch (ParseException ex) {
            reporte.lineas.clear();
            reporte.lineas.add("Ha ocurrido un error inesperado, intente de nuevo.");
            reporte.isError = true;
        }

        return reporte;

    }

    public static void main(String[] args) {

        String archivo = "";
        String fase = "sem";

        if (args.length != 0) {
            archivo = args[0];
        }

        if (archivo.startsWith("-")) {
            fase = archivo.substring(1);

            if (args.length > 1) {
                archivo = args[1];
            }else{
                archivo = "";
            }

        }

        Reporte reporte = null;

        switch (fase) {
            case "l": // Fase léxica
                reporte = lexica(archivo);
                break;
            case "sem": // Fase semántica
                reporte = semantica(archivo);
                break;
            default: // Fase no definida
                reporte = new Reporte();
                reporte.isError = true;
                reporte.lineas.add("ERROR: Esta fase todav\u00eda no est\u00e1 implementada.");
                break;
        }

        try  {
            PrintWriter pw = new PrintWriter("intermedio.txt");

            for (Quadruple q : reporte.codigoIntermedio) {
                pw.println(q.toString());
            }

            reporte.lineas.add("Codigo intermedio creado.");
            pw.close();
        } catch (Exception ex) {
            reporte.lineas.add("ERROR: No se pudo generar el codigo intermedio.");
        }

        reporte.lineas = reporte.lineas.stream()
                                .map(tabMapper)
                                .toList();

        int maxLength = reporte.lineas
                               .stream()
                               .mapToInt(intMapper)
                               .max()
                               .orElse(0);

        // Top border
        System.out.print("\u2554");
        for (int i = 0; i < maxLength + 2; i++) {
            System.out.print("\u2550");
        }
        System.out.println("\u2557");

        // Content with side borders
        for (String linea : reporte.lineas) {
            System.out.printf("\u2551 %-" + maxLength + "s \u2551\n", linea);
        }

        // Bottom border
        System.out.print("\u255a");
        for (int i = 0; i < maxLength + 2; i++) {
            System.out.print("\u2550");
        }
        System.out.println("\u255d");

        if (reporte.isError) {
            System.exit(-1);
        }

        System.exit(0);
    }

    public EC(FileReader fileReader) {
        this((Reader)fileReader);

        token_source.compilador = this;

    }

    private void processError(ParseException ex, String from){

        // Tokens esperados
        StringBuilder expected = new StringBuilder();

        int maxSize = 0;

        for (int i = 0; i < ex.expectedTokenSequences.length; i++) {
            if (maxSize < ex.expectedTokenSequences[i].length) {
                maxSize = ex.expectedTokenSequences[i].length;
            }
            for (int j = 0; j < ex.expectedTokenSequences[i].length; j++) {
                expected.append(tokenImage[ex.expectedTokenSequences[i][j]]).append(' ');
            }

        }

        Token tokenError = ex.currentToken.next;

        // Tokens encontrados
        ArrayList<Token> tokens = new ArrayList<Token>();
        tokens.add(tokenError);

        for (Token t = tokenError; t.next != null; t = t.next) {

            tokens.add(t);
        }

        String[] expecteds = expected.toString().split(" ");

        StringBuilder msg = new StringBuilder();
        msg.append("Error sint\u00e1ctico en ").append(from).append(',')
        .append(" linea ").append(tokenError.endLine).append(", columna ").append(tokenError.endColumn).append('.');

        if (tokens.size() == 1) {

            if(token.kind == ECConstants.CADENA_TEXTO){
                msg.append(String.format("\n\tSe encontr\u00f3 el s\u00edmbolo %s.", tokenImage[token.kind]));
            } else {
                msg.append(String.format("\n\tSe encontr\u00f3 el s\u00edmbolo \"%s\".", token.image));

                if(!tokenImage[tokenError.kind].regionMatches(1, tokenError.image,0,tokenError.image.length()))
                    msg.append(" (").append(tokenImage[tokenError.kind]).append(')').append('.');
            }

        } else {
            msg.append("\n\tSe encontraron los s\u00edmbolos:");
            for (Token token : tokens) {

                if(token.kind == ECConstants.CADENA_TEXTO){
                    msg.append(String.format("\n\t\t - %s.", tokenImage[token.kind]));
                } else {
                    msg.append(String.format("\n\t\t - \"%s\".", token.image));

                    if(!tokenImage[token.kind].regionMatches(1, token.image,0,token.image.length()))
                        msg.append(" (").append(tokenImage[token.kind]).append(')').append('.');
                }

            }
        }

        if (expecteds.length == 1){
            msg.append("\n\tSe esperaba ").append(expecteds[0]).append('.');
        } else {
            msg.append("\n\tSe esperaba uno de los siguientes: ");
            for (String e : expecteds) {
                msg.append("\n\t - ").append(e);
            }
        }

        tablaErrores.add(msg.toString());
        ManejoErrores.registrarError(msg.toString());
        ManejoErrores.guardarErrores(); // ⚠️ Asegurar que se llame aquí
    }

    private void skipTo(Integer end, Integer... kinds) {

        List<Integer> kindsList = Arrays.asList(kinds);

        HashSet<Integer> cKinds = new HashSet<Integer>(kindsList);
        cKinds.add(end);
        cKinds.add(FIN_FUNCION);
        cKinds.add(FIN);
        cKinds.add(EOF);

        Token oldToken = token;
        boolean sw = true;
        int selectedKind = EC.EOF;

        do {
            token = getNextToken();

            for (Integer kind : cKinds) {
                sw &= token.kind != kind;

                if (!sw) {
                    selectedKind = kind;
                    break;
                }
            }

        } while (sw);

        if (selectedKind != end) {
            token = oldToken;
            jj_kind = selectedKind;
        }

    }

// Gramaticas
  final public List<Expresion> argumentos(Ambito ambito) throws ParseException {
    Expresion exp;
    List<Expresion> argumentos = new ArrayList<Expresion>();
    exp = expresion(ambito);
        argumentos.add(exp);
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMA:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      jj_consume_token(COMA);
      exp = expresion(ambito);
            argumentos.add(exp);
    }
        {if (true) return argumentos;}
    throw new Error("Missing return statement in function");
  }

  final public List<Expresion> declaracionArgumentos(Ambito ambito) throws ParseException {
    List<Expresion> argumentos = new ArrayList<Expresion>();

    ExpresionVariable argumento;
    TipoDato tipoDato;
    boolean error = false;
    tipoDato = tiposDato();
    jj_consume_token(VARIABLE);
        String nombre = token.image;
        argumento = new ExpresionVariable(nombre, tipoDato);

        if (ambito.tablaSimbolos.containsKey(nombre)) {

            tablaErrores.add("Error sem\u00e1ntico, L\u00ednea " + token.beginLine + ", columna " + token.beginColumn
                           + ".\n\tEl s\u00edmbolo \"" + nombre + "\" ya est\u00e1 declarado en este \u00e1mbito." +
                             "\n\tQuitar declaraci\u00f3n doble.");
            ManejoErrores.registrarError("Error sem\u00e1ntico, L\u00ednea " + token.beginLine + ", columna " + token.beginColumn
                           + ".\n\tEl s\u00edmbolo \"" + nombre + "\" ya est\u00e1 declarado en este \u00e1mbito." +
                             "\n\tQuitar declaraci\u00f3n doble.");
            ManejoErrores.guardarErrores(); // ⚠️ Asegurar que se llame aquí

            error = true;

        } else {
            ambito.tablaSimbolos.put(nombre, argumento);
            argumentos.add(argumento);
        }
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMA:
        ;
        break;
      default:
        jj_la1[1] = jj_gen;
        break label_2;
      }
      jj_consume_token(COMA);
      tipoDato = tiposDato();
      jj_consume_token(VARIABLE);
            nombre = token.image;
            argumento = new ExpresionVariable(nombre, tipoDato);

            if (ambito.tablaSimbolos.containsKey(nombre)) {

                tablaErrores.add("Error sem\u00e1ntico, L\u00ednea " + token.beginLine + ", columna " + token.beginColumn
                               + ".\n\tEl s\u00edmbolo \"" + nombre + "\" ya est\u00e1 declarado en este \u00e1mbito." +
                                 "\n\tQuitar declaraci\u00f3n doble.");
                ManejoErrores.registrarError("Error sem\u00e1ntico, L\u00ednea " + token.beginLine + ", columna " + token.beginColumn
                               + ".\n\tEl s\u00edmbolo \"" + nombre + "\" ya est\u00e1 declarado en este \u00e1mbito." +
                               "\n\tQuitar declaraci\u00f3n doble.");
                              ManejoErrores.guardarErrores(); // ⚠️ Asegurar que se llame aquí
                error = true;
            } else {
                ambito.tablaSimbolos.put(nombre, argumento);
                argumentos.add(argumento);
            }
    }
        {if (true) return argumentos;}
    throw new Error("Missing return statement in function");
  }

  final public void declaracionFuncion(Ambito ambito) throws ParseException {
    Ambito ambitoFuncion = new Ambito();

    ExpresionFuncion funcion;

    TipoDato tipoDato = TipoDato.VACIO;
    String nombre;
    List<Expresion> argumentos = new ArrayList<Expresion>();

    Expresion ret;

    boolean error = false;
    jj_consume_token(FUNCION);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ENTERO:
    case FLOTANTE:
    case CADENA:
    case CARACTER:
    case BOOLEANO:
      tipoDato = tiposDato();
      break;
    default:
      jj_la1[2] = jj_gen;
      ;
    }
    jj_consume_token(VARIABLE);
        nombre = token.image;
        if (ambito.tablaSimbolos.containsKey(nombre)) {

            tablaErrores.add("Error sem\u00e1ntico, L\u00ednea " + token.beginLine + ", columna " + token.beginColumn
                           + ".\n\tEl s\u00edmbolo \"" + nombre + "\" ya est\u00e1 declarado en este \u00e1mbito." +
                             "\n\tQuitar declaraci\u00f3n doble.");
            ManejoErrores.registrarError("Error sem\u00e1ntico, L\u00ednea " + token.beginLine + ", columna " + token.beginColumn
                           + ".\n\tEl s\u00edmbolo \"" + nombre + "\" ya est\u00e1 declarado en este \u00e1mbito." +
                              "\n\tQuitar declaraci\u00f3n doble.");
                                ManejoErrores.guardarErrores(); // ⚠️ Asegurar que se llame aquí
            error = true;
        }

        new Quadruple(nombre + ":", "", "", 0);
    jj_consume_token(PAREN_ABIERTO);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ENTERO:
    case FLOTANTE:
    case CADENA:
    case CARACTER:
    case BOOLEANO:
      argumentos = declaracionArgumentos(ambitoFuncion);
      break;
    default:
      jj_la1[3] = jj_gen;
      ;
    }
    jj_consume_token(PAREN_CERRADO);
        funcion = new ExpresionFuncion(nombre, tipoDato, argumentos);
        ambitoFuncion.tablaSimbolos.put(nombre, funcion);

        for (Expresion arg : argumentos) {
            arg.toQuadruple();
        }
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTERPRETAR:
      case ESCRIBIR:
      case ESTABLECER:
      case INICIO_CICLO_PARA:
      case INICIO_CICLO_MIENTRAS:
      case INICIO_CICLO_REPETIR:
      case INICIO_CONDICIONAL_SI:
      case INICIO_CONDICIONAL_CONFORME:
      case VARIABLE:
        ;
        break;
      default:
        jj_la1[4] = jj_gen;
        break label_3;
      }
      sentencias(ambitoFuncion);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RETORNAR:
      jj_consume_token(RETORNAR);
      ret = expresion(ambitoFuncion);
      jj_consume_token(DELIMITADOR);
            if (tipoDato.equals(TipoDato.VACIO)) {

                tablaErrores.add("Error sem\u00e1ntico, L\u00ednea " + token.beginLine + ", columna " + token.beginColumn
                               + ".\n\tLa funci\u00f3n \"" + nombre + "\" no puede retornar ningun valor."
                               + "\n\tQuitar retornar.");
                ManejoErrores.registrarError("Error sem\u00e1ntico, L\u00ednea " + token.beginLine + ", columna " + token.beginColumn
              + ".\n\tLa funci\u00f3n \"" + nombre + "\" no puede retornar ningun valor."
                 + "\n\tQuitar retornar.");
                ManejoErrores.guardarErrores(); // ⚠️ Asegurar que se llame aquí

                error = true;
            } else if (!tipoDato.equals(ret.getTipo())) {

                tablaErrores.add("Error sem\u00e1ntico, L\u00ednea " + token.beginLine + ", columna " + token.beginColumn
                               + ".\n\tLa funci\u00f3n \"" + nombre + "\" no puede retornar un tipo de dato \""
                               +  ret.getTipo().getNombre() + "\"."
                               + "\n\tRetornar tipo de dato \"" + tipoDato.getNombre() + "\"." );
                ManejoErrores.registrarError("Error sem\u00e1ntico, L\u00ednea " + token.beginLine + ", columna " + token.beginColumn
                            + ".\n\tLa funci\u00f3n \"" + nombre + "\" no puede retornar un tipo de dato \""
                            +  ret.getTipo().getNombre() + "\"."
                            + "\n\tRetornar tipo de dato \"" + tipoDato.getNombre() + "\"." );
                                ManejoErrores.guardarErrores(); // ⚠️ Asegurar que se llame aquí

                error = true;

            }

            Quadruple q = ret.toQuadruple();
            new Quadruple("ret", q.result, "", "");
      break;
    default:
      jj_la1[5] = jj_gen;
      ;
    }
    jj_consume_token(FIN_FUNCION);
    jj_consume_token(VARIABLE);
        if (!nombre.equals(token.image)) {

            tablaErrores.add("Error sem\u00e1ntico, L\u00ednea " + token.beginLine + ", columna " + token.beginColumn
                           + ".\n\tLa funci\u00f3n debe de terminar con el mismo nombre."
                           + "\n\tColocar el nombre de la funci\u00f3n despu\u00e9s del FinFuncion.");
            ManejoErrores.registrarError("Error sem\u00e1ntico, L\u00ednea " + token.beginLine + ", columna " + token.beginColumn
              + ".\n\tLa funci\u00f3n debe de terminar con el mismo nombre."
              + "\n\tColocar el nombre de la funci\u00f3n despu\u00e9s del FinFuncion.");
            ManejoErrores.guardarErrores(); // ⚠️ Asegurar que se llame aquí

            error = true;
        }

        ambito.tablaSimbolos.put(nombre, funcion.conError(error));
  }

  final public void programa() throws ParseException {
    Ambito ambitoPrincipal = new Ambito();
    try {
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FUNCION:
          ;
          break;
        default:
          jj_la1[6] = jj_gen;
          break label_4;
        }
        declaracionFuncion(ambitoPrincipal);
      }
      jj_consume_token(INICIO);
            new Quadruple("Inicio:", "", "", 0);
      label_5:
      while (true) {
        sentencias(ambitoPrincipal);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTERPRETAR:
        case ESCRIBIR:
        case ESTABLECER:
        case INICIO_CICLO_PARA:
        case INICIO_CICLO_MIENTRAS:
        case INICIO_CICLO_REPETIR:
        case INICIO_CONDICIONAL_SI:
        case INICIO_CONDICIONAL_CONFORME:
        case VARIABLE:
          ;
          break;
        default:
          jj_la1[7] = jj_gen;
          break label_5;
        }
      }
      jj_consume_token(FIN);
      jj_consume_token(0);
        ManejoErrores.guardarErrores();
        System.out.println("DEBUG: Se est\u00e1n guardando errores en errores.log");
    } catch (ParseException ex) {
        processError(ex, "programa principal");

        skipTo(FIN_FUNCION);
    }
  }

  final public void sentencias(Ambito ambito) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ESTABLECER:
      sentenciaDeclaracion(ambito);
      break;
    case VARIABLE:
      sentenciaAsignacion(ambito);
      break;
    case INTERPRETAR:
      leerDato(ambito);
      break;
    case ESCRIBIR:
      imprimirDato(ambito);
      break;
    case INICIO_CONDICIONAL_SI:
      sentenciaSi(ambito);
      break;
    case INICIO_CONDICIONAL_CONFORME:
      sentenciaConforme(ambito);
      break;
    case INICIO_CICLO_PARA:
      sentenciaPara(ambito);
      break;
    case INICIO_CICLO_REPETIR:
      sentenciaRepetir(ambito);
      break;
    case INICIO_CICLO_MIENTRAS:
      sentenciaMientras(ambito);
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void sentenciaAsignacion(Ambito ambito) throws ParseException {
    Expresion exp;
    String nombre = "";
    int dimension = 0;
    try {
      exp = llamadas(ambito);
            if (exp instanceof ExpresionIndice) {
                ExpresionIndice ei = (ExpresionIndice)exp;
                nombre = ei.getArreglo().getNombre();
                dimension = ei.getDimension();
            } else if (exp instanceof ExpresionFuncion) {
                ExpresionFuncion ef = (ExpresionFuncion)exp;
                nombre = ef.getNombre();
            } else if (exp instanceof ExpresionVariable) {
                ExpresionVariable ev = (ExpresionVariable)exp;
                nombre = ev.getNombre();
            }

            if (!ambito.tablaSimbolos.containsKey(nombre)) {
                    ManejoErrores.registrarError("Error sem\u00e1ntico en l\u00ednea " + token.beginLine +
                    ": La variable \"" + nombre + "\" no est\u00e1 declarada.");
                    ManejoErrores.guardarErrores(); // ⚠️ Asegurar que se llame aquí
                }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASIGNACION:
        asignacion(ambito, nombre, dimension);
        break;
      default:
        jj_la1[9] = jj_gen;
        ;
      }
      jj_consume_token(DELIMITADOR);
    } catch (ParseException ex) {
        processError(ex, "sentencia de asignacion");

        skipTo(DELIMITADOR, SENTENCES_BEGIN);
    }
  }

  final public void sentenciaDeclaracion(Ambito ambito) throws ParseException {
    try {
      declaracion(ambito);
      jj_consume_token(DELIMITADOR);
    } catch (ParseException ex) {
        processError(ex, "sentencia de declaraci\u00f3n");

        skipTo(DELIMITADOR, SENTENCES_BEGIN);
    }
  }

  final public TipoDato tiposDato() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ENTERO:
      jj_consume_token(ENTERO);
      break;
    case FLOTANTE:
      jj_consume_token(FLOTANTE);
      break;
    case CADENA:
      jj_consume_token(CADENA);
      break;
    case CARACTER:
      jj_consume_token(CARACTER);
      break;
    case BOOLEANO:
      jj_consume_token(BOOLEANO);
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                   {if (true) return TipoDato.desdeTipo(token.kind << 1);}
    throw new Error("Missing return statement in function");
  }

  final public ExpresionConstante constantes() throws ParseException {
    int fin;
    String str;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NUMERO_ENTERO:
      jj_consume_token(NUMERO_ENTERO);
        {if (true) return new ExpresionConstante(token.image, TipoDato.ENTERO);}
      break;
    case NUMERO_DECIMAL:
      jj_consume_token(NUMERO_DECIMAL);
        {if (true) return new ExpresionConstante(token.image, TipoDato.FLOTANTE);}
      break;
    case CADENA_TEXTO:
      jj_consume_token(CADENA_TEXTO);
        {if (true) return new ExpresionConstante(token.image, TipoDato.CADENA);}
      break;
    case CARACTER_TEXTO:
      jj_consume_token(CARACTER_TEXTO);
        {if (true) return new ExpresionConstante(token.image, TipoDato.CARACTER);}
      break;
    case BOOLEANO_FALSO:
      jj_consume_token(BOOLEANO_FALSO);
        {if (true) return new ExpresionConstante(token.image, TipoDato.BOOLEANO);}
      break;
    case BOOLEANO_VERDADERO:
      jj_consume_token(BOOLEANO_VERDADERO);
        {if (true) return new ExpresionConstante(token.image, TipoDato.BOOLEANO);}
      break;
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void asignacion(Ambito ambito, String nombre, int dimension) throws ParseException {
    boolean error = nombre.isBlank();
    Expresion izq = ERROR;
    Quadruple qIzq = null;

    if (!error && !ambito.tablaSimbolos.containsKey(nombre)) {

        tablaErrores.add("Error sem\u00e1ntico, L\u00ednea " + token.beginLine + ", columna " + token.beginColumn
                        + ".\n\tEl s\u00edmbolo \"" + nombre + "\" no est\u00e1 declarado en este \u00e1mbito." +
                         "\n\tDeclarar el s\u00edmbolo.");
        ManejoErrores.registrarError("Error sem\u00e1ntico en l\u00ednea " + token.beginLine +
                            ": El simbolo \"" + nombre + "\" no est\u00e1 declarado en este ambito.");
                            ManejoErrores.guardarErrores(); // ⚠️ Asegurar que se llame aquí
        error = true;
    }

    if (!error) {
        izq = ambito.tablaSimbolos.get(nombre);
        qIzq = izq.toQuadruple();
    }

    if (!error && !izq.esError() && izq.getTipoExpresion() == Expresion.EXP_FUNCION) {

        tablaErrores.add("Error sem\u00e1ntico, L\u00ednea " + token.beginLine + ", columna " + token.beginColumn
                        + ".\n\t\""+ nombre +"\" no es un s\u00edmbolo asignable." +
                          "\n\tNo se le puede asignar un valor a una llamada de funci\u00f3n.");
        ManejoErrores.registrarError("Error sem\u00e1ntico en l\u00ednea " + token.beginLine +
                            ": La variable \"" + nombre + "\" no es un simbolo asignable.");
                            ManejoErrores.guardarErrores(); // ⚠️ Asegurar que se llame aquí
        error = true;
    }

    Expresion der;
    Token op;
    op = jj_consume_token(ASIGNACION);
    der = expresion(ambito);
        if(der.esError()) {
            error = true;
        }

        TipoDato tipoDatoIzq = izq.getTipo().getTipoInterno(dimension);
        TipoDato tipoDatoDer = der.getTipo();

        if (!tipoDatoIzq.equals(tipoDatoDer)) {
            tablaErrores.add("Error sem\u00e1ntico, L\u00ednea " + op.beginLine + ", columna " + op.beginColumn
                           + ".\n\tNo se puede asignar un tipo de dato \"" + tipoDatoDer.getNombre()
                           + "\" a un tipo de dato \"" +  tipoDatoIzq.getNombre() + "\"."
                           + "\n\tSe esperaba tipo de dato \"" +  tipoDatoIzq.getNombre() + "\".");
        ManejoErrores.registrarError("Error sem\u00e1ntico en l\u00ednea " + token.beginLine +
                            ": No se puede asignar un tipo de dato \"" + tipoDatoDer.getNombre() + "\" a un tipo de dato\""+ tipoDatoIzq.getNombre()
                            + "\"." + "\n\t Se esperaba un tipo de dato \"" + tipoDatoIzq.getNombre() + "\".");
                            ManejoErrores.guardarErrores(); // ⚠️ Asegurar que se llame aquí
        }

        Quadruple qDer = der.toQuadruple();

        new Quadruple("=", qDer.result, "", qIzq.result);
  }

  final public Expresion expresion(Ambito ambito) throws ParseException {
    Expresion expresion;
    expresion = logicoOr(ambito);
        // quadruples.add(expresion.toQuadruple());
        expresion.toQuadruple();
        {if (true) return expresion;}
    throw new Error("Missing return statement in function");
  }

  final public Expresion logicoOr(Ambito ambito) throws ParseException {
    Expresion izq;
    Expresion der;

    List<Expresion> exps = new ArrayList<Expresion>();

    Token op = null;
    int operador = 0;
    boolean error = false;
    izq = logicoAnd(ambito);
        error = izq.esError();

        exps.add(izq);
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LOGICO_OR:
        ;
        break;
      default:
        jj_la1[12] = jj_gen;
        break label_6;
      }
      jj_consume_token(LOGICO_OR);
                    op = token;
      der = logicoAnd(ambito);
            if (!error &&
                (!izq.getTipo().equals(der.getTipo()) ||
                !izq.getTipo().puedeUtilizar(op.kind) || !der.getTipo().puedeUtilizar(op.kind))) {

                tablaErrores.add("Error sem\u00e1ntico, L\u00ednea " + op.beginLine + ", columna " + op.beginColumn
                                + ".\n\tNo se puede aplicar el operador '" + op.image +  "' entre tipos de dato \"" +
                                 izq.getTipo().getNombre() + "\" y \"" + der.getTipo().getNombre() + "\".");
                ManejoErrores.registrarError("Error sem\u00e1ntico, L\u00ednea " + op.beginLine + ", columna " + op.beginColumn
                  + ".\n\tNo se puede aplicar el operador '" + op.image +  "' entre tipos de dato \"" +
                  izq.getTipo().getNombre() + "\" y \"" + der.getTipo().getNombre() + "\".");
                // ⚠️ Asegurar que se llame aquí

                error = true;

            }

            exps.add(der);
            // operador = op.kind;

    }
        {if (true) return hacerBinaria(op, exps).conError(error);}
    throw new Error("Missing return statement in function");
  }

  final public Expresion logicoAnd(Ambito ambito) throws ParseException {
    Expresion izq;
    Expresion der;

    List<Expresion> exps = new ArrayList<Expresion>();

    Token op = null;
    int operador = 0;
    boolean error;
    izq = comparacion(ambito);
        error = izq.esError();

        exps.add(izq);
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LOGICO_AND:
        ;
        break;
      default:
        jj_la1[13] = jj_gen;
        break label_7;
      }
      jj_consume_token(LOGICO_AND);
                     op = token;
      der = comparacion(ambito);
            if (!error &&
                (!izq.getTipo().equals(der.getTipo()) ||
                !izq.getTipo().puedeUtilizar(op.kind) || !der.getTipo().puedeUtilizar(op.kind))) {

                tablaErrores.add("Error sem\u00e1ntico, L\u00ednea " + op.beginLine + ", columna " + op.beginColumn
                                + ".\n\tNo se puede aplicar el operador '" + op.image +  "' entre tipos de dato \"" +
                                 izq.getTipo().getNombre() + "\" y \"" + der.getTipo().getNombre() + "\".");
                ManejoErrores.registrarError("Error sem\u00e1ntico, L\u00ednea " + op.beginLine + ", columna " + op.beginColumn
                + ".\n\tNo se puede aplicar el operador '" + op.image +  "' entre tipos de dato \"" +
                 izq.getTipo().getNombre() + "\" y \"" + der.getTipo().getNombre() + "\".");
                // ⚠️ Asegurar que se llame aquí
                error = true;

            }

            exps.add(der);
            // operador = op.kind;

    }
        {if (true) return hacerBinaria(op, exps).conError(error);}
    throw new Error("Missing return statement in function");
  }

  final public Expresion comparacion(Ambito ambito) throws ParseException {
    Expresion izq;
    Expresion der = null;

    Token op = null;

    int operador = 0;
    boolean error;
    boolean sw = false;
    izq = operando(ambito);
        error = izq.esError();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPERADOR_IGUAL:
    case OPERADOR_DIFERENTE:
    case OPERADOR_MAYOR:
    case OPERADOR_MENOR:
    case OPERADOR_MAYOR_IGUAL:
    case OPERADOR_MENOR_IGUAL:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPERADOR_IGUAL:
        jj_consume_token(OPERADOR_IGUAL);
        break;
      case OPERADOR_DIFERENTE:
        jj_consume_token(OPERADOR_DIFERENTE);
        break;
      case OPERADOR_MAYOR_IGUAL:
        jj_consume_token(OPERADOR_MAYOR_IGUAL);
        break;
      case OPERADOR_MENOR_IGUAL:
        jj_consume_token(OPERADOR_MENOR_IGUAL);
        break;
      case OPERADOR_MAYOR:
        jj_consume_token(OPERADOR_MAYOR);
        break;
      case OPERADOR_MENOR:
        jj_consume_token(OPERADOR_MENOR);
        break;
      default:
        jj_la1[14] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                                                                                                                            op = token;
      der = operando(ambito);
            if (!error &&
                (!izq.getTipo().equals(der.getTipo()) ||
                !izq.getTipo().puedeUtilizar(op.kind) || !der.getTipo().puedeUtilizar(op.kind))) {

                tablaErrores.add("Error sem\u00e1ntico, L\u00ednea " + op.beginLine + ", columna " + op.beginColumn
                                + ".\n\tNo se puede aplicar el operador '" + op.image +  "' entre tipos de dato \"" +
                                 izq.getTipo().getNombre() + "\" y \"" + der.getTipo().getNombre() + "\".");
                ManejoErrores.registrarError("Error sem\u00e1ntico, L\u00ednea " + op.beginLine + ", columna " + op.beginColumn
                 + ".\n\tNo se puede aplicar el operador '" + op.image +  "' entre tipos de dato \"" +
                  izq.getTipo().getNombre() + "\" y \"" + der.getTipo().getNombre() + "\".");
                ManejoErrores.guardarErrores(); // ⚠️ Asegurar que se llame aquí

                error = true;

            }

            sw = true;
      break;
    default:
      jj_la1[15] = jj_gen;
      ;
    }
        if (!sw) {if (true) return izq.conError(error);}

        {if (true) return new ExpresionBinaria(op, izq, der, TipoDato.BOOLEANO).conError(error);}
    throw new Error("Missing return statement in function");
  }

  final public Expresion operando(Ambito ambito) throws ParseException {
    Expresion izq;
    Expresion der;


    List<Token> ops = new ArrayList<Token>();
    List<Expresion> exps = new ArrayList<Expresion>();

    Token op;
    boolean error;
    izq = termino(ambito);
        error = izq.esError();

        exps.add(izq);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SUMA:
      case RESTA:
        ;
        break;
      default:
        jj_la1[16] = jj_gen;
        break label_8;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case RESTA:
        jj_consume_token(RESTA);
        break;
      case SUMA:
        jj_consume_token(SUMA);
        break;
      default:
        jj_la1[17] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
            op = token;

            ops.add(op);
      der = termino(ambito);
            if (!error &&
                (!izq.getTipo().equals(der.getTipo()) ||
                !izq.getTipo().puedeUtilizar(op.kind) || !der.getTipo().puedeUtilizar(op.kind))) {

                tablaErrores.add("Error sem\u00e1ntico, L\u00ednea " + op.beginLine + ", columna " + op.beginColumn
                                + ".\n\tNo se puede aplicar el operador '" + op.image +  "' entre tipos de dato \"" +
                                 izq.getTipo().getNombre() + "\" y \"" + der.getTipo().getNombre() + "\".");
                ManejoErrores.registrarError("Error sem\u00e1ntico, L\u00ednea " + op.beginLine + ", columna " + op.beginColumn
                 + ".\n\tNo se puede aplicar el operador '" + op.image +  "' entre tipos de dato \"" +
                 izq.getTipo().getNombre() + "\" y \"" + der.getTipo().getNombre() + "\".");
                ManejoErrores.guardarErrores(); // ⚠️ Asegurar que se llame aquí

                error = true;

            }

            exps.add(der);
    }
        {if (true) return hacerBinaria(ops, exps).conError(error);}
    throw new Error("Missing return statement in function");
  }

  final public Expresion termino(Ambito ambito) throws ParseException {
    Expresion izq;
    Expresion der;

    List<Token> ops = new ArrayList<Token>();
    List<Expresion> exps = new ArrayList<Expresion>();

    Token op;
    boolean error;
    izq = factor(ambito);
        error = izq.esError();

        exps.add(izq);
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MULTIPLICACION:
      case DIVISION:
      case MODULO:
        ;
        break;
      default:
        jj_la1[18] = jj_gen;
        break label_9;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MULTIPLICACION:
        jj_consume_token(MULTIPLICACION);
        break;
      case DIVISION:
        jj_consume_token(DIVISION);
        break;
      case MODULO:
        jj_consume_token(MODULO);
        break;
      default:
        jj_la1[19] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
            op = token;

            ops.add(op);
      der = factor(ambito);
            if (!error &&
                (!izq.getTipo().equals(der.getTipo())
                || !izq.getTipo().puedeUtilizar(op.kind) || !der.getTipo().puedeUtilizar(op.kind))) {

                tablaErrores.add("Error sem\u00e1ntico, L\u00ednea " + op.beginLine + ", columna " + op.beginColumn
                                + ".\n\tNo se puede aplicar el operador '" + op.image +  "' entre tipos de dato \"" +
                                 izq.getTipo().getNombre() + "\" y \"" + der.getTipo().getNombre() + "\".");
                 ManejoErrores.registrarError("Error sem\u00e1ntico, L\u00ednea " + op.beginLine + ", columna " + op.beginColumn +
                                ".\n\tNo se puede aplicar el operador '" + op.image +  "' entre tipos de dato \"" +
                                 izq.getTipo().getNombre() + "\" y \"" + der.getTipo().getNombre() + "\".");
                 ManejoErrores.guardarErrores(); // ⚠️ Asegurar que se llame aquí

                error = true;

            }

            exps.add(der);
    }
        {if (true) return hacerBinaria(ops, exps).conError(error);}
    throw new Error("Missing return statement in function");
  }

  final public Expresion factor(Ambito ambito) throws ParseException {
    Expresion exp;
    Token op;

    Expresion unario;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VARIABLE:
      exp = llamadas(ambito);
                             {if (true) return exp;}
      break;
    case CADENA_TEXTO:
    case CARACTER_TEXTO:
    case NUMERO_ENTERO:
    case NUMERO_DECIMAL:
    case BOOLEANO_FALSO:
    case BOOLEANO_VERDADERO:
      exp = constantes();
        {if (true) return exp;}
      break;
    case PAREN_ABIERTO:
      jj_consume_token(PAREN_ABIERTO);
      exp = expresion(ambito);
      jj_consume_token(PAREN_CERRADO);
                                                              {if (true) return exp;}
      break;
    case LOGICO_NOT:
      jj_consume_token(LOGICO_NOT);
                   op = token;
      exp = factor(ambito);
        unario = new ExpresionUnaria(op, exp, TipoDato.BOOLEANO);

        if (!exp.getTipo().puedeUtilizar(op.kind)) {

            tablaErrores.add("Error sem\u00e1ntico, L\u00ednea " + op.beginLine + ", columna " + op.beginColumn
                            + ".\n\tNo se puede aplicar el operador '" + op.image +  "' en tipo de dato \"" +
                             exp.getTipo().getNombre() + "\".");
            ManejoErrores.registrarError("Error sem\u00e1ntico, L\u00ednea " + op.beginLine + ", columna " + op.beginColumn
                             + ".\n\tNo se puede aplicar el operador '" + op.image +  "' en tipo de dato \"" +
                             exp.getTipo().getNombre() + "\".");
                             ManejoErrores.guardarErrores(); // ⚠️ Asegurar que se llame aquí

            {if (true) return unario.conError(true);}
        }

        {if (true) return unario;}
      break;
    case SUMA:
    case RESTA:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SUMA:
        jj_consume_token(SUMA);
        break;
      case RESTA:
        jj_consume_token(RESTA);
        break;
      default:
        jj_la1[20] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                          op = token;
      exp = factor(ambito);
        unario = new ExpresionUnaria(op, exp);

        if (!exp.getTipo().puedeUtilizar(op.kind)) {

            tablaErrores.add("Error sem\u00e1ntico, L\u00ednea " + op.beginLine + ", columna " + op.beginColumn
                        + ".\n\tNo se puede aplicar el operador '" + op.image +  "' en tipo de dato \"" +
                         exp.getTipo().getNombre() + "\".");
            ManejoErrores.registrarError("Error sem\u00e1ntico, L\u00ednea " + op.beginLine + ", columna " + op.beginColumn
                         + ".\n\tNo se puede aplicar el operador '" + op.image +  "' en tipo de dato \"" +
                         exp.getTipo().getNombre() + "\".");
            ManejoErrores.guardarErrores(); // ⚠️ Asegurar que se llame aquí

            {if (true) return unario.conError(true);}
        }

        {if (true) return unario;}
      break;
    default:
      jj_la1[21] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Expresion llamadas(Ambito ambito) throws ParseException {
    Expresion exp = ERROR;
    boolean error = false;

    Token v;
    v = jj_consume_token(VARIABLE);
        if (!ambito.tablaSimbolos.containsKey(v.image)) {

            tablaErrores.add("Error sem\u00e1ntico, L\u00ednea " + v.beginLine + ", columna " + v.beginColumn
                            + ".\n\tEl s\u00edmbolo \"" + v.image + "\" no est\u00e1 declarado en este \u00e1mbito." +
                             "\n\tDeclarar el s\u00edmbolo.");
                ManejoErrores.registrarError("Error sem\u00e1ntico en l\u00ednea " + token.beginLine +
                                    ": La variable \"" + v + "\" no est\u00e1 declarada.");
                ManejoErrores.guardarErrores(); // ⚠️ Asegurar que se llame aquí
                error = true;
        }

        if (!error) {
            exp = ambito.tablaSimbolos.get(v.image);
        }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PAREN_ABIERTO:
    case INDICE_ABIERTO:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INDICE_ABIERTO:
            ExpresionIndice indice;
        indice = indiceArreglo(ambito);
            // Comprobar que sean de la misma dimensión
            if (!error) {

                if (!(exp instanceof ExpresionVariable) && !exp.getTipo().esArreglo()) {

                    tablaErrores.add("Error sem\u00e1ntico, L\u00ednea " + v.beginLine + ", columna " + v.beginColumn
                                   + ".\n\tEl s\u00edmbolo \"" + v.image + "\" no es un arreglo.");
                    ManejoErrores.registrarError("Error sem\u00e1ntico, L\u00ednea " + v.beginLine + ", columna " + v.beginColumn
                    + ".\n\tEl s\u00edmbolo \"" + v.image + "\" no es un arreglo.");
                    ManejoErrores.guardarErrores(); // ⚠️ Asegurar que se llame aquí

                    error = true;

                } else if (indice.getDimension() != exp.getTipo().getDimension()) {

                    tablaErrores.add("Error sem\u00e1ntico, L\u00ednea " + v.beginLine + ", columna " + v.beginColumn
                                   + ".\n\tLa dimensi\u00f3n del arreglo con coincide con la cantidad de \u00edndices.");
                     ManejoErrores.registrarError("Error sem\u00e1ntico, L\u00ednea " + v.beginLine + ", columna " + v.beginColumn
                      + ".\n\tLa dimensi\u00f3n del arreglo con coincide con la cantidad de \u00edndices.");
                      ManejoErrores.guardarErrores(); // ⚠️ Asegurar que se llame aquí
                    error = true;

                }

            }

            indice.setArreglo(exp);
            {if (true) return indice.conError(error);}
        break;
      case PAREN_ABIERTO:
            List<Expresion> args = new ArrayList<Expresion>();
        jj_consume_token(PAREN_ABIERTO);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SUMA:
        case RESTA:
        case LOGICO_NOT:
        case PAREN_ABIERTO:
        case CADENA_TEXTO:
        case CARACTER_TEXTO:
        case NUMERO_ENTERO:
        case NUMERO_DECIMAL:
        case BOOLEANO_FALSO:
        case BOOLEANO_VERDADERO:
        case VARIABLE:
          args = argumentos(ambito);
          break;
        default:
          jj_la1[22] = jj_gen;
          ;
        }
        jj_consume_token(PAREN_CERRADO);
            if (!error && exp.getTipoExpresion() != Expresion.EXP_FUNCION) {

                tablaErrores.add("Error sem\u00e1ntico, L\u00ednea " + v.beginLine + ", columna " + v.beginColumn
                               + ".\n\tEl s\u00edmbolo \"" + v.image + "\" no es una funci\u00f3n.");
                ManejoErrores.registrarError("Error sem\u00e1ntico, L\u00ednea " + v.beginLine + ", columna " + v.beginColumn
                 + ".\n\tEl s\u00edmbolo \"" + v.image + "\" no es una funci\u00f3n.");
                ManejoErrores.guardarErrores(); // ⚠️ Asegurar que se llame aquí

                error = true;
            }

            if (!error) {

                ExpresionFuncion ef = (ExpresionFuncion)exp;

                if (!ef.argumentosCompatibles(args)) {

                    tablaErrores.add("Error sem\u00e1ntico, L\u00ednea " + v.beginLine + ", columna " + v.beginColumn
                                   + ".\n\tLos argumentos proporcionados no coinciden con los de la funci\u00f3n.");
                    ManejoErrores.registrarError("Error sem\u00e1ntico, L\u00ednea " + v.beginLine + ", columna " + v.beginColumn
                    + ".\n\tLos argumentos proporcionados no coinciden con los de la funci\u00f3n.");
                    ManejoErrores.guardarErrores(); // ⚠️ Asegurar que se llame aquí
                    error = true;

                }

            }
        break;
      default:
        jj_la1[23] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[24] = jj_gen;
      ;
    }
        {if (true) return exp.conError(error);}
    throw new Error("Missing return statement in function");
  }

  final public ExpresionIndice indiceArreglo(Ambito ambito) throws ParseException {
    Expresion exp;

    List<Expresion> exps = new ArrayList<Expresion>();
    boolean error = false;
    label_10:
    while (true) {
      jj_consume_token(INDICE_ABIERTO);
      exp = expresion(ambito);
      jj_consume_token(INDICE_CERRADO);
            if (!error && !exp.getTipo().equals(TipoDato.ENTERO)) {

                tablaErrores.add("Error sem\u00e1ntico, L\u00ednea " + token.beginLine + ", columna " + token.beginColumn
                                + ".\n\tEl tama\u00f1o o el indice de un arreglo debe ser un entero.");
                ManejoErrores.registrarError("Error sem\u00e1ntico, L\u00ednea " + token.beginLine + ", columna " + token.beginColumn
                 + ".\n\tEl tama\u00f1o o el indice de un arreglo debe ser un entero.");
                 ManejoErrores.guardarErrores(); // ⚠️ Asegurar que se llame aquí

                error = true;
            }

            exps.add(exp);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INDICE_ABIERTO:
        ;
        break;
      default:
        jj_la1[25] = jj_gen;
        break label_10;
      }
    }
        {if (true) return new ExpresionIndice(exps).conError(error);}
    throw new Error("Missing return statement in function");
  }

  final public void declaracion(Ambito ambito) throws ParseException {
    TipoDato tipo;
    boolean error = false;

    ExpresionVariable variable = ERROR;
    jj_consume_token(ESTABLECER);
    tipo = tiposDato();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INDICE_ABIERTO:
            ExpresionIndice indice;
      indice = indiceArreglo(ambito);
            tipo = tipo.getTipoArreglo(indice.getDimension());
      break;
    default:
      jj_la1[26] = jj_gen;
      ;
    }
    jj_consume_token(VARIABLE);
        String nombre = token.image;

        if (ambito.tablaSimbolos.containsKey(nombre)){

            tablaErrores.add("Error sem\u00e1ntico, L\u00ednea " + token.beginLine + ", columna " + token.beginColumn
                            + ".\n\tEl s\u00edmbolo \"" + nombre + "\" ya est\u00e1 declarado en este \u00e1mbito." +
                             "\n\tQuitar declaraci\u00f3n doble.");
            ManejoErrores.registrarError("Error sem\u00e1ntico, L\u00ednea " + token.beginLine + ", columna " + token.beginColumn
            + ".\n\tEl s\u00edmbolo \"" + nombre + "\" ya est\u00e1 declarado en este \u00e1mbito." +
             "\n\tQuitar declaraci\u00f3n doble.");
             ManejoErrores.guardarErrores(); // ⚠️ Asegurar que se llame aquí

            error = true;

        } else {
            variable = new ExpresionVariable(nombre, tipo);
            ambito.tablaSimbolos.put(nombre, variable);
        }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASIGNACION:
      asignacion(ambito, variable.getNombre(), 0);
      break;
    default:
      jj_la1[27] = jj_gen;
      ;
    }
        if(!error) {
            variable.toQuadruple();
        }
  }

  final public void leerDato(Ambito ambito) throws ParseException {
    try {
      jj_consume_token(INTERPRETAR);
      jj_consume_token(VARIABLE);
            String nombre = token.image;
            if (!ambito.tablaSimbolos.containsKey(nombre)){

                tablaErrores.add("Error sem\u00e1ntico, L\u00ednea " + token.beginLine + ", columna " + token.beginColumn
                               + ".\n\tEl s\u00edmbolo \"" + nombre + "\" no est\u00e1 declarado en este \u00e1mbito."
                               + "\n\tDeclare una variable para asignarle un valor.");
                ManejoErrores.registrarError("Error sem\u00e1ntico, L\u00ednea " + token.beginLine + ", columna " + token.beginColumn
                                                                           + ".\n\tEl s\u00edmbolo \"" + nombre + "\" no est\u00e1 declarado en este \u00e1mbito."
                                                                           + "\n\tDeclare una variable para asignarle un valor.");
                             ManejoErrores.guardarErrores(); // ⚠️ Asegurar que se llame aquí
            }

            new Quadruple("Itr", "@" + nombre, "", "");
      jj_consume_token(DELIMITADOR);
    } catch (ParseException ex) {
        processError(ex, "sentencia de lectura de dato");

        skipTo(DELIMITADOR, SENTENCES_BEGIN);
    }
  }

  final public void imprimirDato(Ambito ambito) throws ParseException {
    Expresion exp;
    try {
      jj_consume_token(ESCRIBIR);
      exp = expresion(ambito);
      jj_consume_token(DELIMITADOR);
            Quadruple q = exp.toQuadruple();
            new Quadruple("Esc", q.result, "", "");
    } catch (ParseException ex) {
        processError(ex, "sentencia de escritura de dato");

        skipTo(DELIMITADOR, SENTENCES_BEGIN);
    }
  }

  final public void sentenciaSi(Ambito ambito) throws ParseException {
    Ambito ambitoSi = new Ambito(ambito);
    Expresion condicion;
    Quadruple qCond;
    String etSi = "Si_" + siCount++;
    try {
      jj_consume_token(INICIO_CONDICIONAL_SI);
      condicion = expresion(ambito);
            if (!condicion.getTipo().equals(TipoDato.BOOLEANO)) {

                tablaErrores.add("Error sem\u00e1ntico, L\u00ednea " + token.beginLine + ", columna " + token.beginColumn
                                + ".\n\tEl condicional \"Si\" solo funciona con el tipo de dato Booleano.");
                 ManejoErrores.registrarError("Error sem\u00e1ntico, L\u00ednea " + token.beginLine + ", columna " + token.beginColumn
                                                                             + ".\n\tEl condicional \"Si\" solo funciona con el tipo de dato Booleano.");
                                             ManejoErrores.guardarErrores(); // ⚠️ Asegurar que se llame aquí
            }
            qCond = condicion.toQuadruple();
            new Quadruple("IrSino", qCond.result, etSi, "");
            qCond = null;
      jj_consume_token(ENTONCES);
      label_11:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTERPRETAR:
        case ESCRIBIR:
        case ESTABLECER:
        case INICIO_CICLO_PARA:
        case INICIO_CICLO_MIENTRAS:
        case INICIO_CICLO_REPETIR:
        case INICIO_CONDICIONAL_SI:
        case INICIO_CONDICIONAL_CONFORME:
        case VARIABLE:
          ;
          break;
        default:
          jj_la1[28] = jj_gen;
          break label_11;
        }
        sentencias(ambitoSi);
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CONDICIONAL_SINO:
        jj_consume_token(CONDICIONAL_SINO);
                qCond = new Quadruple(etSi + ":", "", "", "", 0);
                ambitoSi = new Ambito(ambito);
        label_12:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case INTERPRETAR:
          case ESCRIBIR:
          case ESTABLECER:
          case INICIO_CICLO_PARA:
          case INICIO_CICLO_MIENTRAS:
          case INICIO_CICLO_REPETIR:
          case INICIO_CONDICIONAL_SI:
          case INICIO_CONDICIONAL_CONFORME:
          case VARIABLE:
            ;
            break;
          default:
            jj_la1[29] = jj_gen;
            break label_12;
          }
          sentencias(ambitoSi);
        }
        break;
      default:
        jj_la1[30] = jj_gen;
        ;
      }
      jj_consume_token(FIN_CONDICIONAL_SI);
            if(qCond == null) new Quadruple(etSi + ":", "", "", "", 0);
    } catch (ParseException ex) {
        processError(ex, "sentencia condicional Si");

        skipTo(FIN_CONDICIONAL_SI);
    }
  }

  final public void sentenciaConforme(Ambito ambito) throws ParseException {
    boolean error = false;

    Ambito ambitoConforme;
    HashSet<String> casos = new HashSet<String>();

    Expresion exp = ERROR;
    ExpresionConstante constante;

    String conformeId = "Conforme_" + conCount++;
    int casoCount = 1;
    ArrayList<Quadruple> qCasos = new ArrayList<Quadruple>();
    try {
      jj_consume_token(INICIO_CONDICIONAL_CONFORME);
      jj_consume_token(VARIABLE);
            if (!ambito.tablaSimbolos.containsKey(token.image)) {

                tablaErrores.add("Error sem\u00e1ntico, L\u00ednea " + token.beginLine + ", columna " + token.beginColumn
                               + ".\n\tEl s\u00edmbolo \"" + token.image + "\" no est\u00e1 declarado en este \u00e1mbito."
                               + "\n\tDeclare una variable para asignarle un valor.");
                ManejoErrores.registrarError("Error sem\u00e1ntico, L\u00ednea " + token.beginLine + ", columna " + token.beginColumn
                               + ".\n\tEl s\u00edmbolo \"" + token.image + "\" no est\u00e1 declarado en este \u00e1mbito."
                               + "\n\tDeclare una variable para asignarle un valor.");
                ManejoErrores.guardarErrores(); // ⚠️ Asegurar que se llame aquí

                error = true;

            } else {

                exp = ambito.tablaSimbolos.get(token.image);

                if (exp.getTipoExpresion() != Expresion.EXP_VARIABLE) {

                    tablaErrores.add("Error sem\u00e1ntico, L\u00ednea " + token.beginLine + ", columna " + token.beginColumn
                                   + ".\n\tLa sentencia \"Segun\" solo funciona con variables.");
                ManejoErrores.registrarError("Error sem\u00e1ntico, L\u00ednea " + token.beginLine + ", columna " + token.beginColumn
                                   + ".\n\tLa sentencia \"Segun\" solo funciona con variables.");
                ManejoErrores.guardarErrores(); // ⚠️ Asegurar que se llame aquí
                    error = true;

                }
            }
      jj_consume_token(HACER);
      label_13:
      while (true) {
        jj_consume_token(CASO);
        constante = constantes();
                if (!error && !exp.getTipo().equals(constante.getTipo())){

                    tablaErrores.add("Error sem\u00e1ntico, L\u00ednea " + token.beginLine + ", columna " + token.beginColumn
                                   + ".\n\tTipo de dato del caso err\u00f3neo."
                                   + "\n\tEl caso debe tener un valor constante \"" + exp.getTipo().getNombre()  +"\".");
                ManejoErrores.registrarError("Error sem\u00e1ntico, L\u00ednea " + token.beginLine + ", columna " + token.beginColumn
                                                                                + ".\n\tTipo de dato del caso err\u00f3neo."
                                                                                + "\n\tEl caso debe tener un valor constante \"" + exp.getTipo().getNombre()  +"\".");
                ManejoErrores.guardarErrores(); // ⚠️ Asegurar que se llame aquí
                    error = true;

                } else if (!casos.add(constante.getValor())) {

                    tablaErrores.add("Error sem\u00e1ntico, L\u00ednea " + token.beginLine + ", columna " + token.beginColumn
                                   + ".\n\tEl caso \"" + constante.getValor() + "\" ya existe."
                                   + "\n\tElimine caso repetido.");
                ManejoErrores.registrarError("Error sem\u00e1ntico, L\u00ednea " + token.beginLine + ", columna " + token.beginColumn
                                                                                + ".\n\tEl caso \"" + constante.getValor() + "\" ya existe."
                                                                                + "\n\tElimine caso repetido.");
                ManejoErrores.guardarErrores(); // ⚠️ Asegurar que se llame aquí
                    error = true;
                }

                ambitoConforme = new Ambito(ambito);
        jj_consume_token(OPERADOR_DOS_PUNTOS);
        label_14:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case INTERPRETAR:
          case ESCRIBIR:
          case ESTABLECER:
          case INICIO_CICLO_PARA:
          case INICIO_CICLO_MIENTRAS:
          case INICIO_CICLO_REPETIR:
          case INICIO_CONDICIONAL_SI:
          case INICIO_CONDICIONAL_CONFORME:
          case VARIABLE:
            ;
            break;
          default:
            jj_la1[31] = jj_gen;
            break label_14;
          }
          sentencias(ambitoConforme);
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CASO:
          ;
          break;
        default:
          jj_la1[32] = jj_gen;
          break label_13;
        }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CASO_PREDETERMINADO:
        jj_consume_token(CASO_PREDETERMINADO);
        jj_consume_token(OPERADOR_DOS_PUNTOS);
        label_15:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case INTERPRETAR:
          case ESCRIBIR:
          case ESTABLECER:
          case INICIO_CICLO_PARA:
          case INICIO_CICLO_MIENTRAS:
          case INICIO_CICLO_REPETIR:
          case INICIO_CONDICIONAL_SI:
          case INICIO_CONDICIONAL_CONFORME:
          case VARIABLE:
            ;
            break;
          default:
            jj_la1[33] = jj_gen;
            break label_15;
          }
          sentencias(ambitoConforme);
        }
        break;
      default:
        jj_la1[34] = jj_gen;
        ;
      }
      jj_consume_token(FIN_CONFORME);
            for (String caso : casos) {

            }
    } catch (ParseException ex) {
        processError(ex, "sentencia condicional Conforme");

        skipTo(FIN_CONFORME);
    }
  }

  final public void sentenciaPara(Ambito ambito) throws ParseException {
    Ambito ambitoPara = new Ambito(ambito);

    Token v;
    Expresion condicion;

    String cicloId = "Ciclo_" + cicCount++;
    try {
      jj_consume_token(INICIO_CICLO_PARA);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VARIABLE:
        v = jj_consume_token(VARIABLE);
        asignacion(ambito, v.image, 0);
        break;
      case ESTABLECER:
        declaracion(ambitoPara);
        break;
      default:
        jj_la1[35] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(CONDICION_CICLO_PARA);
      condicion = expresion(ambitoPara);
            if (!condicion.getTipo().equals(TipoDato.BOOLEANO)) {

                tablaErrores.add("Error sem\u00e1ntico, L\u00ednea " + token.beginLine + ", columna " + token.beginColumn
                                + ".\n\tEl condicional del ciclo \"Para\" solo funciona con el tipo de dato Booleano.");
                    ManejoErrores.registrarError("Error sem\u00e1ntico, L\u00ednea " + token.beginLine + ", columna " + token.beginColumn
                                                                                + ".\n\tEl condicional del ciclo \"Para\" solo funciona con el tipo de dato Booleano.");
                    ManejoErrores.guardarErrores(); // ⚠️ Asegurar que se llame aquí

            }
      jj_consume_token(INCREMENTO_CICLO_PARA);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NUMERO_ENTERO:
        jj_consume_token(NUMERO_ENTERO);
        break;
      case NUMERO_DECIMAL:
        jj_consume_token(NUMERO_DECIMAL);
        break;
      default:
        jj_la1[36] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_16:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTERPRETAR:
        case ESCRIBIR:
        case ESTABLECER:
        case INICIO_CICLO_PARA:
        case INICIO_CICLO_MIENTRAS:
        case INICIO_CICLO_REPETIR:
        case INICIO_CONDICIONAL_SI:
        case INICIO_CONDICIONAL_CONFORME:
        case VARIABLE:
          ;
          break;
        default:
          jj_la1[37] = jj_gen;
          break label_16;
        }
        sentencias(ambitoPara);
      }
      jj_consume_token(FIN_CICLO_PARA);
    } catch (ParseException ex) {
        processError(ex, "sentencia de bucle Para");

        skipTo(FIN_CICLO_PARA);
    }
  }

  final public void sentenciaRepetir(Ambito ambito) throws ParseException {
    Ambito ambitoRepetir = new Ambito(ambito);

    Expresion condicion;
    try {
      jj_consume_token(INICIO_CICLO_REPETIR);
      label_17:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTERPRETAR:
        case ESCRIBIR:
        case ESTABLECER:
        case INICIO_CICLO_PARA:
        case INICIO_CICLO_MIENTRAS:
        case INICIO_CICLO_REPETIR:
        case INICIO_CONDICIONAL_SI:
        case INICIO_CONDICIONAL_CONFORME:
        case VARIABLE:
          ;
          break;
        default:
          jj_la1[38] = jj_gen;
          break label_17;
        }
        sentencias(ambitoRepetir);
      }
      jj_consume_token(CONDICION_CICLO_REPETIR);
      condicion = expresion(ambito);
            if (!condicion.getTipo().equals(TipoDato.BOOLEANO)) {

                tablaErrores.add("Error sem\u00e1ntico, L\u00ednea " + token.beginLine + ", columna " + token.beginColumn
                                + ".\n\tEl condicional del ciclo \"Repetir\" solo funciona con el tipo de dato Booleano.");
                ManejoErrores.registrarError("Error sem\u00e1ntico, L\u00ednea " + token.beginLine + ", columna " + token.beginColumn
                                + ".\n\tEl condicional del ciclo \"Repetir\" solo funciona con el tipo de dato Booleano.");
                ManejoErrores.guardarErrores(); // ⚠️ Asegurar que se llame aquí

            }
      jj_consume_token(DELIMITADOR);
    } catch (ParseException ex) {
        processError(ex, "sentencia de bucle Repetir");

        skipTo(DELIMITADOR, SENTENCES_BEGIN);
    }
  }

  final public void sentenciaMientras(Ambito ambito) throws ParseException {
    Ambito ambitoMientras = new Ambito(ambito);

    Expresion condicion;
    try {
      jj_consume_token(INICIO_CICLO_MIENTRAS);
      condicion = expresion(ambito);
            if (!condicion.getTipo().equals(TipoDato.BOOLEANO)) {

                tablaErrores.add("Error sem\u00e1ntico, L\u00ednea " + token.beginLine + ", columna " + token.beginColumn
                                + ".\n\tEl condicional del ciclo \"Mientras\" solo funciona con el tipo de dato Booleano.");
                ManejoErrores.registrarError("Error sem\u00e1ntico, L\u00ednea " + token.beginLine + ", columna " + token.beginColumn
                                + ".\n\tEl condicional del ciclo \"Mientras\" solo funciona con el tipo de dato Booleano.");
                                ManejoErrores.guardarErrores(); // ⚠️ Asegurar que se llame aquí
            }
      jj_consume_token(HACER);
      label_18:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTERPRETAR:
        case ESCRIBIR:
        case ESTABLECER:
        case INICIO_CICLO_PARA:
        case INICIO_CICLO_MIENTRAS:
        case INICIO_CICLO_REPETIR:
        case INICIO_CONDICIONAL_SI:
        case INICIO_CONDICIONAL_CONFORME:
        case VARIABLE:
          ;
          break;
        default:
          jj_la1[39] = jj_gen;
          break label_18;
        }
        sentencias(ambitoMientras);
      }
      jj_consume_token(FIN_CICLO_MIENTRAS);
    } catch (ParseException ex) {
        processError(ex, "sentencia de bucle Mientras");

        skipTo(FIN_CICLO_MIENTRAS);
    }
  }

  /** Generated Token Manager. */
  public ECTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[40];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x8,0x8,0xf80,0xf80,0x7000,0x40,0x10,0x7000,0x7000,0x8000,0xf80,0x0,0x400000,0x200000,0x3f000000,0x3f000000,0x30000,0x30000,0x1c0000,0x1c0000,0x30000,0x80830000,0x80830000,0x80000000,0x80000000,0x0,0x0,0x8000,0x7000,0x7000,0x0,0x7000,0x0,0x7000,0x0,0x4000,0x0,0x7000,0x7000,0x7000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x21151000,0x0,0x0,0x21151000,0x21151000,0x0,0x0,0x7e0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200007e0,0x200007e0,0x2,0x2,0x2,0x2,0x0,0x21151000,0x21151000,0x400000,0x21151000,0x2000000,0x21151000,0x4000000,0x20000000,0x180,0x21151000,0x21151000,0x21151000,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }

  /** Constructor with InputStream. */
  public EC(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public EC(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new ECTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 40; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 40; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public EC(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new ECTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 40; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 40; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public EC(ECTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 40; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(ECTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 40; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List jj_expentries = new java.util.ArrayList();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[69];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 40; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 69; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
